Index: lint_plugin/src/mir_analyzer.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/mir_analyzer.rs b/lint_plugin/src/mir_analyzer.rs
--- a/lint_plugin/src/mir_analyzer.rs	
+++ b/lint_plugin/src/mir_analyzer.rs	
@@ -24,7 +24,7 @@
     inference_ctx::InferenceCtx,
     name_registry::NameRegistry,
     folder::Foldable,
-    refinable_entity::RefinableEntity,
+    refinable_entity::RefinableEntityData,
     error::TypeError,
     utils::ANN_RET_NAME
 };
@@ -84,6 +84,8 @@
     /// registry to get globals/functions refinements from
     restriction_registry: R,
     z3: &'z mut Z3,
+    /// Mapping from variable version to
+    vars: HashMap<RefinableEntity, RefinableEntityData<'tcx>>,
     /// all type errors, collected during body check
     errors: Vec<TypeError>,
 }
@@ -115,6 +117,7 @@
 
     /// Perform function mir liquid type inference and check
     pub fn check(&mut self) -> Result<bool, failure::Error> {
+        self.init_local_var_versions();
         let init_refinements = self.init_locals_refinements();
         let basic_blocks = self.mir.basic_blocks();
         if let Some(return_bb) = basic_blocks
@@ -199,7 +202,7 @@
                     }));
                     let predicate = expr.into();
                     let refinement = Refinement::new(place.ty(self.mir, self.tcx).ty.kind.clone(), predicate);
-                    ctx.refine(RefinableEntity::from_place(place.clone(), self.def_id), refinement)
+                    ctx.refine(RefinableEntityData::from_place(place.clone(), self.def_id), refinement)
                 }
                 StatementKind::StorageLive(_) => {
                     // ??????
@@ -262,7 +265,7 @@
                     TyKind::Uint(_) => Ok(Const::UInt { size: value_size, bits: value }),
                     t => Err(failure::format_err!("Invalid switch ty: {:?}", t))
                 };
-                let discr_re = RefinableEntity::from_place(discr_local.clone(), self.def_id);
+                let discr_re = RefinableEntityData::from_place(discr_local.clone(), self.def_id);
                 if let Some(&value) = values.get(target_idx) {
                     let expr = Expr::v_eq(Expr::Const(cnst(value)?));
                     let refinement = Refinement::new(switch_ty.kind.clone(), expr.into());
@@ -301,7 +304,7 @@
                         let dst_type = dst.ty(self_body.local_decls(), tcx).ty.kind.clone();
                         let v_ty = (&dst_type).try_into().ok();
                         base_lqt.refine(
-                            RefinableEntity::from_place(dst.clone(), self_id),
+                            RefinableEntityData::from_place(dst.clone(), self_id),
                             Refinement::new(
                                 dst_type,
                                 postcondition
@@ -351,7 +354,7 @@
                     unreachable!()
                 };
                 let refinement = Refinement::new(TyKind::Bool, pred);
-                base_lqt.refine(RefinableEntity::from_place(local.clone(), self.def_id), refinement);
+                base_lqt.refine(RefinableEntityData::from_place(local.clone(), self.def_id), refinement);
                 base_lqt
             }
             // explicitly list all rest variants to not skip something
@@ -375,6 +378,7 @@
         }
         let predecessors = self.mir.predecessors_for(current_block);
         let pred_lqt: Vec<_> = if predecessors.is_empty() {
+            // it is initial bb
             let mut locals_init_lqt = self.init_locals_refinements();
             let self_refinement = self.self_refinement();
             let self_precondition = self_refinement.pre().clone();
@@ -418,7 +422,7 @@
                 v_ty
             },
         })?.into());
-        ctx.refine(RefinableEntity::from_place(RETURN_PLACE.into(), fun_id), refinement);
+        ctx.refine(RefinableEntityData::from_place(RETURN_PLACE.into(), fun_id), refinement);
         Ok(ctx)
     }
 
@@ -439,7 +443,7 @@
                         v_ty,
                     },
                 })?.into());
-                ctx.refine(RefinableEntity::from_place(local.into(), fun_id), refinement);
+                ctx.refine(RefinableEntityData::from_place(local.into(), fun_id), refinement);
                 Ok(ctx)
             })
     }
@@ -450,7 +454,7 @@
     /// we need to add assertions `a=x`,`b=y`,`c=z` to ctx
     fn merge_ctx_with_args(&self, mut ctx: InferenceCtx<'tcx>, args: &[Operand<'tcx>], mir: &Body, fun_id: DefId) -> InferenceCtx<'tcx> {
         for (actual, formal) in args.into_iter().zip(mir.args_iter()) {
-            let target = RefinableEntity::from_place(formal.into(), fun_id);
+            let target = RefinableEntityData::from_place(formal.into(), fun_id);
             match actual {
                 Operand::Constant(box value) => {
                     ctx.refine(target, Refinement::new(
@@ -470,18 +474,18 @@
         ctx
     }
 
-    fn merge_ctx_with_args2(ctx: &mut InferenceCtx<'tcx>, mapping: HashMap<RefinableEntity<'tcx>, (TyKind<'tcx>, Expr<'tcx>)>) {
+    fn merge_ctx_with_args2(ctx: &mut InferenceCtx<'tcx>, mapping: HashMap<RefinableEntityData<'tcx>, (TyKind<'tcx>, Expr<'tcx>)>) {
         for (formal, (ty, expr)) in mapping {
             ctx.refine(formal, Refinement::new(ty, Expr::v_eq(expr).into()));
         }
     }
 
     /// Return mapping from formal parameter to actual argument, actually to Expr::Var or Expr::Const
-    fn formal_to_actual_mapping(&self, args: &[Operand<'tcx>], body: &Body, fun_id: DefId) -> HashMap<RefinableEntity<'tcx>, (TyKind<'tcx>, Expr<'tcx>)> {
+    fn formal_to_actual_mapping(&self, args: &[Operand<'tcx>], body: &Body, fun_id: DefId) -> HashMap<RefinableEntityData<'tcx>, (TyKind<'tcx>, Expr<'tcx>)> {
         args.into_iter()
             .zip(body.args_iter())
             .map(|(actual, formal)|
-                (RefinableEntity::from_place(formal.into(), fun_id),
+                (RefinableEntityData::from_place(formal.into(), fun_id),
                  match actual {
                      Operand::Constant(box value) => (value.literal.ty.kind.clone(), value.literal.into()),
                      Operand::Copy(value) | Operand::Move(value) => (
@@ -616,7 +620,7 @@
     }
 
     /// Infer lqt of rvalue in cxt
-    fn infer_lqt(&self, v: &Rvalue<'tcx>, target_place: Place<'tcx>, ctx: &mut InferenceCtx<'tcx>) {
+    fn infer_lqt(&mut self, v: &Rvalue<'tcx>, target: RefinableEntity, bb: BasicBlock, ctx: &mut InferenceCtx<'tcx>) {
         match *v {
             // simple assign one value to another, no less no more
             Rvalue::Use(ref oprnd) => {
@@ -632,7 +636,7 @@
 //                        unimplemented!("constant assign")
                     }
                 };
-                ctx.refine(RefinableEntity::from_place(target_place, self.def_id), rhs_lqt);
+                ctx.refine(RefinableEntityData::from_place(target, self.def_id), rhs_lqt);
             }
             Rvalue::Repeat(_, _) => unimplemented!("array literal"),
             Rvalue::Ref(_, _, _) => unimplemented!("reference"),
@@ -652,6 +656,7 @@
                 let rhs_ty = rhs_op.ty(self.mir.local_decls(), self.tcx);
                 let op_ty = op.ty(self.tcx, lhs_ty, rhs_ty);
                 let value_lqt = Refinement::new(op_ty.kind.clone(), pred);
+                let target_place = self.vars.get(&target).expect(&format!("No var for version {}", target)).place();
                 let projection = target_place.projection.to_vec();
                 let value_place = Place {
                     base: target_place.base.clone(),
@@ -662,20 +667,23 @@
                     },
                 };
                 let flag_place = Place {
-                    base: target_place.base,
+                    base: target_place.base.clone(),
                     projection: {
                         let mut projection = projection.clone();
                         projection.push(ProjectionElem::Field(Field::from(1usize), self.tcx.mk_bool()));
                         self.tcx.intern_place_elems(&projection)
                     },
                 };
-                let value_re = RefinableEntity::from_place(value_place, self.def_id);
-                ctx.refine(value_re, value_lqt);
+                let value_re = RefinableEntityData::from_place(value_place, self.def_id);
+                let value_var = self.intern_entity_data(value_re, bb);
+                ctx.refine(value_var, value_lqt);
 
                 let result_overflows = Expr::v_eq(Expr::binary_op(BinOp::overflows(op.into()), lhs, rhs)).into();
                 let flag_lqt = Refinement::new(TyKind::Bool, result_overflows);
                 // TODO: turn on back
-                ctx.refine(RefinableEntity::from_place(flag_place, self.def_id), flag_lqt);
+                let flag_re = RefinableEntityData::from_place(flag_place, self.def_id);
+                let flag_var = self.intern_entity_data(flag_re, bb);
+                ctx.refine(flag_var, flag_lqt);
             }
             // TODO: check here that overflow is impossible
             | Rvalue::BinaryOp(op, ref lhs, ref rhs) => {
@@ -686,7 +694,7 @@
                 let lhs_ty = lhs.ty(self.mir.local_decls(), self.tcx);
                 let rhs_ty = rhs.ty(self.mir.local_decls(), self.tcx);
                 let rhs_lqt = Refinement::new(op.ty(self.tcx, lhs_ty, rhs_ty).kind.clone(), pred);
-                ctx.refine(RefinableEntity::from_place(target_place, self.def_id), rhs_lqt);
+                ctx.refine(RefinableEntityData::from_place(target, self.def_id), rhs_lqt);
             }
 
             Rvalue::NullaryOp(op, rhs) => {
@@ -698,7 +706,7 @@
                 let pred = expr.into();
                 let rhs_ty = rhs.ty(self.mir.local_decls(), self.tcx);
                 let rhs_lqt = Refinement::new(rhs_ty.kind.clone(), pred);
-                ctx.refine(RefinableEntity::from_place(target_place, self.def_id), rhs_lqt);
+                ctx.refine(RefinableEntityData::from_place(target, self.def_id), rhs_lqt);
             }
             Rvalue::Discriminant(ref p) => {
                 // need new operator <discr_of> to describe value of target place
@@ -743,8 +751,30 @@
                 LocalKind::Var => self.get_var_refinement(local),
                 LocalKind::Temp => self.get_tmp_refinement(local)
             };
-            ctx.refine(RefinableEntity::from_place(idx.into(), self.def_id), refinement)
+            ctx.refine(RefinableEntityData::from_place(idx.into(), self.def_id), refinement)
         }
         ctx
     }
+
+    fn init_local_var_versions(&mut self) {
+        // threat user-defined vars and compiler-generated ones as uninitialized initially
+        let locals = self.mir.vars_and_temps_iter();
+        let initial_bb: BasicBlock = if let Some(bb) = self.mir.basic_blocks().indices().next() {
+            bb
+        } else {
+            return
+        };
+
+        for local in locals {
+
+            self.var_versions.insert((local.into(), initial_bb), vec![RefinableEntity::new(initial_bb)]);
+        }
+    }
+
+    fn intern_entity_data(&mut self, data: RefinableEntityData<'tcx>, bb: BasicBlock) -> RefinableEntity {
+        // let var = self.var_versions.get(&(data.place().clone(), bb))
+        let var = RefinableEntity::new(bb);
+        self.vars.insert(var, data);
+        var
+    }
 }
Index: lint_plugin/src/expr.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/expr.rs b/lint_plugin/src/expr.rs
--- a/lint_plugin/src/expr.rs	
+++ b/lint_plugin/src/expr.rs	
@@ -4,7 +4,7 @@
 };
 use rustc_target::abi::Size;
 use derive_more::*;
-use crate::refinable_entity::RefinableEntity;
+use crate::refinable_entity::{RefinableEntityData, RefinableEntity};
 use rustc::hir::def_id::DefId;
 use crate::typable::{Typable, Ty, Typer};
 
@@ -186,7 +186,7 @@
     #[display(fmt = "v")]
     V,
     #[display(fmt = "{:?}", _0)]
-    Var(RefinableEntity<'tcx>),
+    Var(RefinableEntityData<'tcx>),
     #[display(fmt = "{}", _0)]
     Const(Const),
     #[display(fmt = "{} {}", _0, _1)]
@@ -198,7 +198,7 @@
 pub trait ExprFolder {
     type T;
     fn fold_v() -> Self::T;
-    fn fold_var(var: RefinableEntity) -> Self::T;
+    fn fold_var(var: RefinableEntityData) -> Self::T;
     fn fold_const(r#const: Const) -> Self::T;
     fn fold_unaryop(unaryop: UnaryOp, expr: Expr) -> Self::T;
     fn fold_binaryop(binop: BinOp, lhs: Expr, rhs: Expr) -> Self::T;
@@ -222,7 +222,11 @@
     }
 
     pub fn from_place(place: Place<'tcx>, fun_id: DefId) -> Self {
-        Self::Var(RefinableEntity::from_place(place, fun_id))
+        Self::Var(RefinableEntityData::from_place(place, fun_id))
+    }
+
+    pub fn from_refinable_entity(refinable_entity: RefinableEntity) -> Self {
+        Self::Var(RefinableEntityData)
     }
 
     pub fn from_operand(op: Operand<'tcx>, fun_id: DefId) -> Self {
Index: lint_plugin/src/refinable_entity.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/refinable_entity.rs b/lint_plugin/src/refinable_entity.rs
--- a/lint_plugin/src/refinable_entity.rs	
+++ b/lint_plugin/src/refinable_entity.rs	
@@ -1,20 +1,32 @@
 use derive_more::Display;
-use rustc::mir::{Local, Place, Body, RETURN_PLACE};
+use rustc::mir::{Local, Place, Body, RETURN_PLACE, BasicBlock};
 use crate::utils::ANN_RET_NAME;
 use rustc::hir::def_id::DefId;
 use crate::typable::{Typable, Ty, Typer};
 
-#[derive(Clone, PartialEq, Eq, Hash, Debug, Display)]
-#[display(fmt = "<{:?}: {:?}>", fun_id, place)]
-pub struct RefinableEntity<'tcx> {
+pub struct RefinableEntityData<'tcx> {
     fun_id: DefId,
     place: Place<'tcx>,
 }
 
-impl<'tcx> RefinableEntity<'tcx> {
+/// This type corresponds to some version of variable
+/// in some basic block.
+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, Display)]
+#[display(fmt = "<{:?}_{:?}>", version.0, version.1)]
+pub struct RefinableEntity {
+    version: (BasicBlock, usize)
+}
+
+impl RefinableEntity {
+    pub fn new(bb: BasicBlock) -> RefinableEntity {
+        Self { version: (bb, 0) }
+    }
+}
+
+impl<'tcx> RefinableEntityData<'tcx> {
     /// Body must refer to self.fun_id
     pub fn name(&self, body: &Body) -> Option<String> {
-        if let Some(local)= self.place.as_local() {
+        if let Some(local) = self.place.as_local() {
             if local == RETURN_PLACE {
                 ANN_RET_NAME.to_owned().into()
             } else {
@@ -51,13 +63,13 @@
     }
 }
 
-impl<'tcx, T: Typer<'tcx>> Typable<'tcx, T> for RefinableEntity<'tcx> {
+impl<'tcx, T: Typer<'tcx>> Typable<'tcx, T> for RefinableEntityData<'tcx> {
     fn ty(&self, typer: &T) -> Option<Ty> {
         typer.ty(self).into()
     }
 }
 
-impl<'tcx> Into<Place<'tcx>> for RefinableEntity<'tcx> {
+impl<'tcx> Into<Place<'tcx>> for RefinableEntityData<'tcx> {
     fn into(self) -> Place<'tcx> {
         self.place
     }
Index: lint_plugin/src/z3_interface.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/z3_interface.rs b/lint_plugin/src/z3_interface.rs
--- a/lint_plugin/src/z3_interface.rs	
+++ b/lint_plugin/src/z3_interface.rs	
@@ -1,9 +1,4 @@
-use std::{
-    collections::{
-        hash_map::RandomState,
-        HashMap,
-    }
-};
+use std::collections::HashMap;
 
 use failure::_core::hint::unreachable_unchecked;
 use rustc::ty::TyKind;
@@ -24,16 +19,15 @@
 
 use crate::{
     expr::{BinOp, Const, Expr, UnaryOp},
-    refinable_entity::RefinableEntity,
+    refinable_entity::RefinableEntityData,
     refined_type::Predicate,
-    to_smt::{Decls, DefaultSmtConverterCtx, SmtConverterCtx, SMTIdx, ToSmt},
+    to_smt::{SmtConverterCtx, SMTIdx, ToSmt},
     typable::{Ty, Typable, Typer},
 };
 use crate::utils::IntoFish;
-use rustc::ty::layout::MaybeResult;
 
 type Solver = SMTLib2<LIA>;
-type Names<'tcx, 'e> = HashMap<RefinableEntity<'tcx>, <Solver as SMTBackend>::Idx>;
+type Names<'tcx, 'e> = HashMap<RefinableEntityData<'tcx>, <Solver as SMTBackend>::Idx>;
 
 impl<'tcx, C: SmtConverterCtx<'tcx, QF_AUFBV>> ToSmt<'tcx, QF_AUFBV, C> for Const {
     type Output = SMTIdx<QF_AUFBV>;
@@ -143,7 +137,7 @@
     Some(sort)
 }
 
-impl<'tcx, L: Logic, C: SmtConverterCtx<'tcx, L>> ToSmt<'tcx, L, C> for RefinableEntity<'tcx> {
+impl<'tcx, L: Logic, C: SmtConverterCtx<'tcx, L>> ToSmt<'tcx, L, C> for RefinableEntityData<'tcx> {
     type Output = SMTIdx<L>;
     fn to_smt(&self, ctx: &mut C) -> Option<Self::Output> {
         ctx.get_name(self)
@@ -156,7 +150,7 @@
 fn smt_from_var(
     s: &mut Solver,
     names: &Names,
-    ref_entity: &RefinableEntity,
+    ref_entity: &RefinableEntityData,
 ) -> <Solver as SMTBackend>::Idx {
     *names.get(ref_entity).ok_or(failure::format_err!("Unknown variable to convert into SMT {:?}\nnames: {:?}", ref_entity, names)).unwrap()
 //    match place.base {
Index: lint_plugin/src/name_registry.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/name_registry.rs b/lint_plugin/src/name_registry.rs
--- a/lint_plugin/src/name_registry.rs	
+++ b/lint_plugin/src/name_registry.rs	
@@ -3,11 +3,11 @@
     hir::def_id::DefId,
 };
 use std::collections::HashMap;
-use crate::refinable_entity::RefinableEntity;
+use crate::refinable_entity::RefinableEntityData;
 
 pub struct NameRegistry<'tcx, 'b> {
     bodies: &'b HashMap<DefId, &'tcx Body<'tcx>>,
-    pub names: HashMap<RefinableEntity<'tcx>, String>,
+    pub names: HashMap<RefinableEntityData<'tcx>, String>,
     counter: usize,
 }
 
@@ -20,7 +20,7 @@
         }
     }
 
-    pub fn get(&mut self, var: RefinableEntity<'tcx>) -> &str {
+    pub fn get(&mut self, var: RefinableEntityData<'tcx>) -> &str {
         if !self.names.contains_key(&var) {
             let bodies = &self.bodies;
             let counter = &mut self.counter;
@@ -47,7 +47,7 @@
         self.names.get(&var).unwrap()
     }
 
-    pub fn get_existing(&mut self, var: &RefinableEntity<'tcx>) -> Option<&str> {
+    pub fn get_existing(&mut self, var: &RefinableEntityData<'tcx>) -> Option<&str> {
         self.names.get(var).map(|v| v.as_str())
     }
 }
Index: lint_plugin/src/typable.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/typable.rs b/lint_plugin/src/typable.rs
--- a/lint_plugin/src/typable.rs	
+++ b/lint_plugin/src/typable.rs	
@@ -1,5 +1,5 @@
 use rustc::mir::Body;
-use crate::refinable_entity::RefinableEntity;
+use crate::refinable_entity::RefinableEntityData;
 use rustc::ty::{TyCtxt, TyKind};
 use std::convert::{TryFrom, TryInto};
 use std::collections::HashMap;
@@ -35,7 +35,7 @@
 }
 
 pub trait Typer<'tcx> {
-    fn ty(&self, v: &RefinableEntity<'tcx>) -> Ty;
+    fn ty(&self, v: &RefinableEntityData<'tcx>) -> Ty;
     fn v_ty(&self) -> Option<Ty>;
 }
 
@@ -46,7 +46,7 @@
 }
 
 impl<'b, 'mir, 'tcx> Typer<'tcx> for DefaultTyper<'b, 'mir, 'tcx> {
-    fn ty(&self, v: &RefinableEntity<'tcx>) -> Ty {
+    fn ty(&self, v: &RefinableEntityData<'tcx>) -> Ty {
         let body = self.bodies.get(&v.fun_id()).expect(&format!("No body for fun_id {:?}", v.fun_id()));
         (&v.place().ty(*body, self.tcx).ty.kind).try_into().unwrap_or_else(|k| panic!("TyKind {:?} has no corresponding type", k))
     }
Index: lint_plugin/src/smt_ctx.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/smt_ctx.rs b/lint_plugin/src/smt_ctx.rs
--- a/lint_plugin/src/smt_ctx.rs	
+++ b/lint_plugin/src/smt_ctx.rs	
@@ -1,5 +1,5 @@
 use crate::to_smt::{SmtConverterCtx, SMTIdx, Decls, DefaultSmtConverterCtx};
-use crate::refinable_entity::RefinableEntity;
+use crate::refinable_entity::RefinableEntityData;
 use crate::typable::{Typer, Ty, DefaultTyper};
 use rustc::ty::TyCtxt;
 use rustproof_libsmt::backends::smtlib2::SMTLib2;
@@ -60,17 +60,17 @@
 }
 
 impl<'tcx, T, L: Logic, S: SmtConverterCtx<'tcx, L>> SmtConverterCtx<'tcx, L> for SmtCtx<L, T, S> {
-    fn get_name(&self, var: &RefinableEntity<'tcx>) -> Option<SMTIdx<L>> {
+    fn get_name(&self, var: &RefinableEntityData<'tcx>) -> Option<SMTIdx<L>> {
         self.smt_converter.get_name(var)
     }
 
-    fn add_name(&mut self, var: RefinableEntity<'tcx>, idx: SMTIdx<L>) {
+    fn add_name(&mut self, var: RefinableEntityData<'tcx>, idx: SMTIdx<L>) {
         self.smt_converter.add_name(var, idx);
     }
 }
 
 impl<'tcx, L, S, T: Typer<'tcx>> Typer<'tcx> for SmtCtx<L, T, S> {
-    fn ty(&self, v: &RefinableEntity<'tcx>) -> Ty {
+    fn ty(&self, v: &RefinableEntityData<'tcx>) -> Ty {
         self.typer.ty(v)
     }
 
Index: lint_plugin/src/to_smt.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/to_smt.rs b/lint_plugin/src/to_smt.rs
--- a/lint_plugin/src/to_smt.rs	
+++ b/lint_plugin/src/to_smt.rs	
@@ -1,16 +1,16 @@
 use rustproof_libsmt::backends::smtlib2::SMTLib2;
 use rustproof_libsmt::backends::backend::{Logic, SMTBackend};
 use std::collections::HashMap;
-use crate::refinable_entity::RefinableEntity;
+use crate::refinable_entity::RefinableEntityData;
 use std::ops::DerefMut;
 use failure::_core::ops::Deref;
 
 pub type SMTIdx<L> = <SMTLib2<L> as SMTBackend>::Idx;
-pub type Decls<'tcx, L> = HashMap<RefinableEntity<'tcx>, SMTIdx<L>>;
+pub type Decls<'tcx, L> = HashMap<RefinableEntityData<'tcx>, SMTIdx<L>>;
 
 pub trait SmtConverterCtx<'tcx, L: Logic>: DerefMut<Target = SMTLib2<L>> {
-    fn get_name(&self, var: &RefinableEntity<'tcx>) -> Option<SMTIdx<L>>;
-    fn add_name(&mut self, var: RefinableEntity<'tcx>, idx: SMTIdx<L>);
+    fn get_name(&self, var: &RefinableEntityData<'tcx>) -> Option<SMTIdx<L>>;
+    fn add_name(&mut self, var: RefinableEntityData<'tcx>, idx: SMTIdx<L>);
 }
 
 #[derive(Debug)]
@@ -33,11 +33,11 @@
 }
 
 impl<'tcx, L: Logic> SmtConverterCtx<'tcx, L> for DefaultSmtConverterCtx<'tcx, L> {
-    fn get_name(&self, var: &RefinableEntity<'tcx>) -> Option<SMTIdx<L>> {
+    fn get_name(&self, var: &RefinableEntityData<'tcx>) -> Option<SMTIdx<L>> {
         self.names.get(var).copied()
     }
 
-    fn add_name(&mut self, var: RefinableEntity<'tcx>, idx: SMTIdx<L>) {
+    fn add_name(&mut self, var: RefinableEntityData<'tcx>, idx: SMTIdx<L>) {
         self.names.insert(var, idx);
     }
 }
Index: lint_plugin/src/inference_ctx.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/lint_plugin/src/inference_ctx.rs b/lint_plugin/src/inference_ctx.rs
--- a/lint_plugin/src/inference_ctx.rs	
+++ b/lint_plugin/src/inference_ctx.rs	
@@ -3,19 +3,24 @@
     fmt
 };
 use crate::{
-    refinable_entity::RefinableEntity,
     refined_type::{Refinement, Predicate}
 };
 use itertools::Itertools;
+use crate::refinable_entity::RefinableEntity;
 
-pub type RefinementMap<'tcx> = HashMap<RefinableEntity<'tcx>, Refinement<'tcx>>;
+pub type RefinementMap<'tcx> = HashMap<RefinableEntity, Refinement<'tcx>>;
 /// Holds inferred types of local variables;
 #[derive(Clone, Debug, Default)]
 pub struct InferenceCtx<'tcx> {
+    checks: RefinementMap<'tcx>,
     // need some type here to represent qualifiable entities, such as function args,
     // function return, locals, temps, struct fields and slice elems.
     // seems that Place is power enough for that purpose
     refinements: RefinementMap<'tcx>,
+    // variables versions
+//    vars_versions: HashMap<Place, RefinableEntity>,
+    // path conditions of transition from given predecessor to current basic block
+//    path_conditions: HashMap<BasicBlock, Refinement>
 }
 
 impl fmt::Display for InferenceCtx<'_> {
@@ -33,11 +38,11 @@
         Self { refinements }
     }
 
-    pub fn get_refinement(&self, p: &RefinableEntity<'tcx>) -> Refinement<'tcx> {
+    pub fn get_refinement(&self, p: &RefinableEntity) -> Refinement<'tcx> {
         self.refinements[p].clone()
     }
 
-    pub fn refine(&mut self, var: RefinableEntity<'tcx>, lqt: Refinement<'tcx>) {
+    pub fn refine(&mut self, var: RefinableEntity, lqt: Refinement<'tcx>) {
         // we need to assign more specific type to var, provided by lqt
         // and also check that it is compatible with existing one
         // conjoin predicates
@@ -58,7 +63,7 @@
         }
     }
 
-    fn updated(&self, var: RefinableEntity<'tcx>, lqt: Refinement<'tcx>) -> Self {
+    fn updated(&self, var: RefinableEntity, lqt: Refinement<'tcx>) -> Self {
         let mut res = self.clone();
         res.refine(var, lqt);
         res
